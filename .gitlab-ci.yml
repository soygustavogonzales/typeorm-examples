include:
  - project: 'cencosud-ds/utils/gitops-deploy'
    ref: master
    file:
      - '.gitlab-ci-deploy-script.yml'
      - '.gitlab-ci-docker-definition.yml'
      - '.gitlab-ci-kubernetes-runner.yml'

image: registry.gitlab.com/cencosud-ds/utils/docker-images/node:12.19.0-alpine3.10

include:
  - project: 'cencosud-ds/utils/gitops-deploy'
    ref: master
    file: '.gitlab-ci-deploy-script.yml'

cache:
  paths:
    - node_modules/

stages:
  - test
  - build
  - package
  - staging deploy
  - production deploy

build:
  stage: build
  before_script:
    - apk update && apk add bash openjdk8 python g++ make && rm -rf /var/cache/apk/*
    - export JAVA_HOME=/usr/lib/jvm/java-1.8-openjdk
    - npm ci
  script:
    - npm run build
  tags:
    - private
    - staging
    - cache
  artifacts:
    paths:
      - dist/

dockerize:
  image: registry.gitlab.com/cencosud-ds/utils/docker-images/docker:stable
  stage: package
  services:
    - docker:stable-dind
  # variables:
    # DOCKER_HOST: tcp://localhost:2375
    # DOCKER_DRIVER: overlay2
  tags:
    - private
    - cache
    - staging
  before_script:
    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com
  only:
    - branches
  script:
    - export TAG="$CI_COMMIT_REF_NAME-$CI_PIPELINE_IID-$CI_COMMIT_SHORT_SHA"
    - export IMAGE_TAG="$CI_REGISTRY_IMAGE:$TAG"
    - echo $IMAGE_TAG
    - docker build --network host -t $IMAGE_TAG -f docker/Dockerfile .
    - docker push $IMAGE_TAG
    - docker tag $IMAGE_TAG $CI_REGISTRY_IMAGE:airflow
    - docker push $CI_REGISTRY_IMAGE:airflow

# Nombre del job
.deploy_script: &deploy_script 
  # Indicamos que queremos heredar la configuración del script de deploy que incluímos en el fragmento anterior
  # Recordar descartar el anterior.
  extends: .deploy
  script:
    # Ingresamos al path
    - cd $KUSTOMIZE_PATH
    # Generamos una variable que contenga la url de la imagen docker, rama y ejecución del mismo pipeline 
    # NOTA: En el stage de docker debe existir de igual manera.
    - export TAG="$CI_COMMIT_REF_NAME-$CI_PIPELINE_IID-$CI_COMMIT_SHORT_SHA"
    - export IMAGE_TAG="$CI_REGISTRY_IMAGE:$TAG"
    # Establecemos la imagen en kustomize.
    - kustomize edit set image ${IMAGE_TAG}
    # Generamos el/los secreto(s) necesario(s) que tienen que coincidir con el deployment.
    # Recordar hacerlo con el mismo con los secretos adicionales de tu aplicación
    - | 
      kubectl create secret docker-registry gitlab-auth-${CI_PROJECT_NAME} \
           --docker-server=${CI_REGISTRY} \
           --docker-username=${CI_DEPLOY_USER} \
           --docker-password=${CI_DEPLOY_PASSWORD} \
           -n ${NAMESPACE} --dry-run=client -o yaml \
           > /tmp/docker-pull-secrets.yaml
    # Encriptamos el secreto con sealed secrets. La variable KUBESEAL_ENDPOINT aún no la definimos ojo!! 
    - kubeseal --cert ${KUBESEAL_ENDPOINT} < /tmp/docker-pull-secrets.yaml > docker-pull-secrets.yaml -o yaml
    # Añadimos el nuevo secreto encriptado a recurso a kustomize
    - kustomize edit add resource docker-pull-secrets.yaml
    # Secreto adicional
    - |
      kubectl -n $NAMESPACE create secret generic ${CI_PROJECT_NAME}-secrets \
        --from-literal=TYPEORM_HOST=$TYPEORM_HOST \
        --from-literal=TYPEORM_PORT="$TYPEORM_PORT" \
        --from-literal=TYPEORM_USERNAME=$TYPEORM_USERNAME \
        --from-literal=TYPEORM_PASSWORD=$TYPEORM_PASSWORD \
        --from-literal=TYPEORM_DATABASE=$TYPEORM_DATABASE \
        --from-literal=TYPEORM_LOGGING=schema \
        --from-literal=JWT_SECRET=$JWT_SECRET \
        --from-literal=API_KEY=$API_KEY \
        --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
        --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
        --from-literal=API_SECURITY_KEY=$API_SECURITY_KEY \
        --from-literal=API_STYLES_KEY=$API_STYLES_KEY \
        --from-literal=AS400HOST=$AS400HOST \
        --from-literal=AS400USER=$AS400USER \
        --from-literal=AS400PASS=$AS400PASS \
        --from-literal=AS400PGMSKU=$AS400PGMSKU \
        --from-literal=AWS_REGION=$AWS_REGION \
        --from-literal=AWS_QUEUE_SQS_JDA_SKU_SYNC_URL=$AWS_QUEUE_SQS_JDA_SKU_SYNC_URL \
        -o yaml --dry-run=client > /tmp/$CI_PROJECT_NAME-secrets.yaml
    # Encriptamos secreto adicional
    - kubeseal --cert ${KUBESEAL_ENDPOINT} < /tmp/$CI_PROJECT_NAME-secrets.yaml > $CI_PROJECT_NAME-secret.yaml -o yaml
    # Añadimos recursos a kustomize
    - kustomize edit add resource $CI_PROJECT_NAME-secret.yaml
    # Volvemos al directorio superior y subimos los cambios.
    - cd ..
    - git add .
    - git commit -m "[skip ci] - Updating k8s manifests for ${CI_PROJECT_NAME} commit $CI_COMMIT_SHORT_SHA" || echo "No changes, nothing to commit!"
    - git push origin HEAD:$CI_COMMIT_REF_NAME

Green Staging:
  <<: *deploy_script
  stage: staging deploy
  tags:
    - private
    - staging
    - cache
  variables:
    # Path de la variante de kustomize
    KUSTOMIZE_PATH: ./kustomize/overlays/staging/green
    # Endpoint de kubeseal
    KUBESEAL_ENDPOINT: ${PARISTECH_KUBESEAL_STAGING_ENDPOINT}
    NAMESPACE: paris-cl-ecosistema-compra
  only:
    - branches
  environment:
    name: dev
  when: manual

Green Production:
  <<: *deploy_script
  stage: production deploy
  tags:
    - private
    - production
    - cache
  variables:
    # Path de la variante de kustomize
    KUSTOMIZE_PATH: ./kustomize/overlays/production/green
    # Endpoint de kubeseal
    KUBESEAL_ENDPOINT: ${PARISTECH_KUBESEAL_PRODUCTION_ENDPOINT}
    NAMESPACE: paris-cl-ecosistema-compra
  only:
    - master
  environment:
    name: prd
  when: manual


# Despliega las credenciales en un repositorio unificado para que argocd realice el despliege
.gitops_deploy_definition: &gitops_deploy_definition
  extends: .deploy_git_ssh
  script:
    - git clone git@gitlab.com:cencosud-ds/arquitectura-plataforma/data-arq/airflow-secrets.git
    - mkdir -p airflow-secrets/${AS_ENVIRONMENT_NAME}/namespaces/$NAMESPACE && cd "$_"
    - git checkout master
    - echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}" >> /tmp/secrets.file
    - echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}" >> /tmp/secrets.file
    - echo "TYPEORM_HOST=${TYPEORM_HOST}" >> /tmp/secrets.file
    - echo "TYPEORM_PORT=${TYPEORM_PORT}" >> /tmp/secrets.file
    - echo "TYPEORM_USERNAME=${TYPEORM_USERNAME}" >> /tmp/secrets.file
    - echo "TYPEORM_PASSWORD=${TYPEORM_PASSWORD}" >> /tmp/secrets.file
    - echo "TYPEORM_DATABASE=${TYPEORM_DATABASE}" >> /tmp/secrets.file
    - echo "TYPEORM_LOGGING=schema" >> /tmp/secrets.file
    - echo "AWS_SNS_TOPIC_ARN=${AWS_SNS_TOPIC_ARN}" >> /tmp/secrets.file
    - echo "API_SECURITY_KEY=${API_SECURITY_KEY}" >> /tmp/secrets.file
    - echo "API_STYLES_KEY=${API_STYLES_KEY}" >> /tmp/secrets.file
    - echo "AWS_QUEUE_SQS_JDA_SKU_SYNC_URL=${AWS_QUEUE_SQS_JDA_SKU_SYNC_URL}" >> /tmp/secrets.file
    - echo "API_KEY=${API_KEY}" >> /tmp/secrets.file
    - echo "AS400HOST=${AS400HOST}" >> /tmp/secrets.file
    - echo "AS400USER=${AS400USER}" >> /tmp/secrets.file
    - echo "AS400PASS=${AS400PASS}" >> /tmp/secrets.file
    - echo "AS400PGMSKU=${AS400PGMSKU}" >> /tmp/secrets.file
    - echo "JWT_SECRET=${JWT_SECRET}" >> /tmp/secrets.file
    - |
      kubectl create secret generic ${CI_PROJECT_NAME}-secrets \
        --namespace=$NAMESPACE \
        --from-env-file=/tmp/secrets.file \
        --dry-run=client -o yaml \
        > /tmp/${CI_PROJECT_NAME}-secrets.yaml
    - kubeseal --cert ${KUBESEAL_ENDPOINT} < /tmp/${CI_PROJECT_NAME}-secrets.yaml > ${CI_PROJECT_NAME}-secrets.yaml -o yaml
    - |
      kubectl create secret docker-registry gitlab-auth-$CI_PROJECT_NAME \
        --docker-server=$CI_REGISTRY \
        --docker-username=$CI_DEPLOY_USER \
        --docker-password=$CI_DEPLOY_PASSWORD \
        -n $NAMESPACE --dry-run=client -o yaml \
        > /tmp/gitlab-auth-$CI_PROJECT_NAME.yaml
    - kubeseal --cert ${KUBESEAL_ENDPOINT} < /tmp/gitlab-auth-$CI_PROJECT_NAME.yaml > gitlab-auth-$CI_PROJECT_NAME.yaml -o yaml
    - cd ../../../
    - git add .
    - git commit -m "[skip ci] - Updating k8s manifests for ${CI_PROJECT_NAME} in environment ${CI_ENVIRONMENT_NAME}, commit $CI_COMMIT_SHORT_SHA" || echo "No changes, nothing to commit!"
    - git push origin master

Airflow Staging:
  <<: *gitops_deploy_definition
  stage: staging deploy
  variables:
    AS_ENVIRONMENT_NAME: staging
    KUBESEAL_ENDPOINT: ${PARISTECH_KUBESEAL_STAGING_ENDPOINT}
    NAMESPACE: paris-cl-ecosistema-compra
  environment:
    name: dev
  tags:
    - private
    - staging
  only:
    refs:
      - branches

Airflow Production:
  <<: *gitops_deploy_definition
  stage: production deploy
  variables:
    AS_ENVIRONMENT_NAME: production
    KUBESEAL_ENDPOINT: ${PARISTECH_KUBESEAL_PRODUCTION_ENDPOINT}
    NAMESPACE: paris-cl-ecosistema-compra
  environment:
    name: prd
  tags:
    - private
    - production
  only:
    refs:
      - master
